#include canvas:shaders/pipeline/pipeline.glsl
#include frex:shaders/lib/math.glsl
#include frex:shaders/api/world.glsl
#include lomo:shaders/lib/linear.glsl

uniform samplerCube u_skybox;

layout(location = 0) out vec3 face[6];

const int steps = 16;

const vec2[steps] points = vec2[steps](
	vec2(0.007703673406754033, 0.11786293693575021),
	vec2(0.07973561892157174, -0.10158605381345262),
	vec2(-0.1389499198211783, -0.10953939563085843),
	vec2(-0.22974318725672896, 0.09229163748502481),
	vec2(0.2359269683922347, 0.08964886297652344),
	vec2(0.15810896556427864, -0.29083800117296116),
	vec2(-0.10247364297198835, 0.31575764937133965),
	vec2(0.1524837589893688, 0.31771371836731677),
	vec2(0.3314650083194238, -0.12192654327414788),
	vec2(-0.10882060015500618, -0.347790116980921),
	vec2(-0.30899572080621307, -0.26085813012369263),
	vec2(-0.4241981974142176, -0.07617095221041796),
	vec2(-0.3467934254177238, 0.2949468225438013),
	vec2(0.44074892300469437, 0.13554422400481533),
	vec2(-0.4828891671902746, 0.1294295911247319),
	vec2(0.02307442816906403, 0.5033516599047605)//,
	//vec2(0.3569909829787715, 0.36205673507498115),
	//vec2(0.023012968608117388, -0.5104350314044506),
	//vec2(0.2512158214250035, -0.4745750171554641),
	//vec2(-0.25457324098858286, 0.49473614610480293),
	//vec2(0.5449351888875571, -0.14544944200105922),
	//vec2(0.4474386598025013, -0.34853764185072467),
	//vec2(-0.46891926441108867, -0.41207775562048227),
	//vec2(-0.31795562245908965, -0.5400639818478369),
	//vec2(-0.5979902978996481, -0.22922062428134277),
	//vec2(0.6384140444918203, 0.06183910655984743),
	//vec2(0.18545399338775673, 0.6304085435370993),
	//vec2(-0.15291002044277602, -0.6519037624195815),
	//vec2(0.5840601587234595, 0.32861244040667476),
	//vec2(-0.6802320741035297, 0.010005398200510099),
	//vec2(-0.5071609800757895, 0.46214946514556493),
	//vec2(-0.1293700946811771, 0.6803745844107115),
	//vec2(0.3991579259483671, 0.5691114357475016),
	//vec2(-0.6533662467237721, 0.2618699294403008),
	//vec2(0.21176224807981747, -0.6936919543332919),
	//vec2(0.4390160438573208, -0.5929121051889273),
	//vec2(-0.3733280842643329, 0.6789226587292505),
	//vec2(0.7106147125996497, -0.3114194543329919),
	//vec2(0.012883014742535238, -0.7758142382675778),
	//vec2(0.7839271917864905, -0.09905847610213375),
	//vec2(0.7842531700582359, 0.2225259251313126),
	//vec2(-0.6748275758051867, -0.4604712534511751),
	//vec2(0.0389741195263836, 0.8179658998360473),
	//vec2(0.6399467155230861, -0.5192942509640992),
	//vec2(-0.8063506927657814, -0.1913287399294151),
	//vec2(0.6348491838593424, 0.5447263976572151),
	//vec2(-0.36916261183671706, -0.7773509465343216),
	//vec2(0.3161001209356061, 0.810613915410719),
	//vec2(-0.7282841578516667, 0.4845486994955296),
	//vec2(-0.5504091470157844, -0.681890860721874),
	//vec2(-0.865132117025529, 0.25428771850100096),
	//vec2(-0.9059055191505523, 0.034433383397486785),
	//vec2(-0.5987424944716992, 0.6936471097399153),
	//vec2(0.3962193623399221, -0.8264959587481557),
	//vec2(0.5445133916882803, 0.7519553857805834),
	//vec2(-0.18007184076472954, 0.9152838426942537),
	//vec2(-0.209855082142877, -0.9097032549505532),
	//vec2(0.8267533013696046, 0.4463364534216025),
	//vec2(0.19753466453142193, -0.937006807893421),
	//vec2(0.9572447383377135, 0.10557438658069793),
	//vec2(-0.39433264644417376, 0.8859619948867203),
	//vec2(0.5939741367491976, -0.7724046809632362),
	//vec2(-0.911483352533768, -0.38470549788527747),
	//vec2(0.8736484585581386, -0.48607258853323426)
);

vec3 sky(mat3 z_to_w, vec3 dir) {
	int previous_layer = frxu_lod - 1;

	vec3 d = z_to_w * dir;

	vec3 perp_x = normalize(cross(d, vec3(-d.y, d.x, -d.z)));
	vec3 perp_y = normalize(cross(d, perp_x));

	//float sn = 

	//mat3 m = mat3(
	//	vec3(d.z, -d.y, -d.x),
	//	cross(vec3(d.z, -d.y, -d.x), d.xyz),
	//	d.xyz
	//);

	float radius = PI * 1.0 / pow(2.0, max(0.0, float(6 - previous_layer)));

	vec3 result = vec3(0.0);

	float weight_sum = 0.0;

	for(int i = 0; i < steps; ++i) {
		vec2 c_pos = points[i];

		vec3 r =
			rotation(radius * c_pos.y, perp_y) *
			rotation(radius * c_pos.x, perp_x) *
			d;
		//r = z_to_w * r;
		// vec3 r1 = rotation(radius * c_pos.y, r0) * d;

		float weight = 1.0;//exp(-dot(c_pos, c_pos) * 2.0);

		vec3 t = textureLod(u_skybox, r, previous_layer).rgb;
		result += t * weight;
		weight_sum += weight;
	}

	return result / weight_sum;
}

void main() {
	// d is a direction to a positive Z
	vec3 d = normalize(
		vec3(gl_FragCoord.xy / frxu_size.xy - 0.5, 0.5)
	);
	d.y *= -1.0;

	const vec3 y_axis = vec3(0, 1, 0);
	const vec3 x_axis = vec3(1, 0, 0);

	// sky function takes world-space view direction
	face[0] = sky(rotation( PI / 2.0, y_axis), d);
	face[1] = sky(rotation(-PI / 2.0, y_axis), d);
	face[2] = sky(rotation(-PI / 2.0, x_axis), d);
	face[3] = sky(rotation( PI / 2.0, x_axis), d);
	face[4] = sky(mat3(1.0),                   d);
	face[5] = sky(rotation( PI,       y_axis), d);
}